# 网络编程

## 传统的网络编程

在 Linux 下进行 C 语言网络编程时，主要依赖于 POSIX 标准定义的系统调用和库函数。这些 API 提供了对网络通信的底层支持，包括创建套接字（Socket）、绑定地址、监听连接、接受连接、发送和接收数据等操作。

下图是一个典型的网络编程流程图：

```
       server               client
    +----------+         +----------+
    |  socket  |         |  socket  |
    +----------+         +----------+
        |                     |     
        |                     |     
        |                     |     
        v                     |     
    +----------+              |     
    |   bind   |              |     
    +----------+              |     
        |                     |     
        |                     |     
        |                     |     
        v                     |     
    +----------+              |     
    |  listen  |              |     
    +----------+              v     
        |               +----------+
        | <------------ |  connect |
        |               +----------+
        v                     |     
    +----------+              |     
    |  accept  |              |     
    +----------+              |     
        |                     |     
        |                     |     
        |                     |     
        v                     v     
    +----------+         +----------+
    | send/recv| <------ | send/recv|
    +----------+         +----------+
```

### 创建套接字

使用 `socket()` 系统调用来创建一个套接字。

```c
int socket(int domain, int type, int protocol);
```

参数说明：

- domain：指定协议族，如 AF_INET（IPv4）、AF_INET6（IPv6）或 AF_UNIX（本地通信）。
- type：指定套接字类型，如 SOCK_STREAM（TCP）、SOCK_DGRAM（UDP）或 SOCK_RAW（原始套接字）。
- protocol：指定协议，通常设置为 0，表示使用默认协议。

返回值：
- 成功时返回一个套接字描述符（非负整数）。
- 失败时返回 -1，并设置 errno。

### 绑定地址

使用 `bind()` 系统调用来将套接字绑定到一个本地地址和端口。

```c
int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```

参数说明：
- sockfd：套接字描述符。
- addr：指向 struct sockaddr 的指针，包含要绑定的地址和端口信息。
- addrlen：地址结构的长度。

返回值：
- 成功时返回 0。
- 失败时返回 -1，并设置 errno。

### 监听连接

使用 `listen()` 系统调用来将套接字转换为被动套接字，使其能够接收连接请求。

```c
int listen(int sockfd, int backlog);
```

参数说明：
- sockfd：套接字描述符。
- backlog：指定未完成连接队列的最大长度。

返回值：
- 成功时返回 0。
- 失败时返回 -1，并设置 errno。

### 接受连接

使用 `accept()` 系统调用来接受一个连接请求，返回一个新的套接字描述符用于与客户端通信。

```c
int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
```

参数说明：

- sockfd：监听套接字描述符。
- addr：指向 struct sockaddr 的指针，用于存储客户端地址信息。
- addrlen：地址结构的长度。


返回值：

- 成功时返回一个新的套接字描述符。
- 失败时返回 -1，并设置 errno。

### 发送和接收数据

使用 `send()` 和 `recv()` 系统调用来发送和接收数据。

```c
ssize_t send(int sockfd, const void* buf, size_t len, int flags);
ssize_t recv(int sockfd, void* buf, size_t len, int flags);
```

参数说明：
- sockfd：套接字描述符。
- buf：指向数据缓冲区的指针。
- len：缓冲区的长度。
- flags：控制选项，如 0（默认）、MSG_OOB（带外数据）等。

返回值：
- send()：成功时返回发送的字节数，失败时返回 -1。
- recv()：成功时返回接收的字节数，失败时返回 -1，到达文件末尾时返回 0。

### 关闭套接字

使用 `close()` 系统调用来关闭套接字。

```c
int close(int sockfd);
```

参数说明：
- sockfd：套接字描述符。

返回值：
- 成功时返回 0。
- 失败时返回 -1，并设置 errno。

### 示例代码：TCP 服务器

以下是一个简单的 TCP 服务器示例，展示了如何使用上述 API。

```{literalinclude} /src/libuv/tcp-server/main.c
:language: c
```

### 示例代码：TCP 客户端

以下是一个简单的 TCP 客户端示例，展示了如何使用上述 API。

```{literalinclude} /src/libuv/tcp-client/main.c
:language: c
```

### 示例代码：UDP 服务器

```{literalinclude} /src/libuv/udp-server/main.c
:language: c
```

### 示例代码：UDP 客户端

```{literalinclude} /src/libuv/udp-client/main.c
:language: c
```

## libuv 的网络编程

libuv 的网络编程 API 并不与 POSIX 网络 API 一一对应，而是对其进行了封装和抽象，提供了更高层次的异步 I/O 接口。libuv 的设计目标是跨平台和事件驱动，因此它的 API 更注重异步操作和事件循环，而不是直接映射 POSIX 的同步 API。

### TCP 相关 API

#### uv_tcp_init

`uv_tcp_init` 用于初始化 TCP 句柄，相当于 POSIX 的 `socket` 函数。

```c
int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle);
```

参数说明：
- loop: 事件循环对象（uv_loop_t）。
- handle: TCP 句柄（uv_tcp_t）。

#### uv_tcp_bind

将 TCP 句柄绑定到指定的地址和端口，相当于 POSIX 的 `bind` 函数。

```c
int uv_tcp_bind(uv_tcp_t* handle, const struct sockaddr* addr, unsigned int flags);
```

参数说明:
- handle: TCP 句柄（uv_tcp_t）。
- addr: 地址信息（struct sockaddr）。
- flags: 绑定标志（如 UV_TCP_IPV6ONLY）。

#### uv_listen

开始监听连接请求，相当于 POSIX 的 `listen` 函数。

```c
int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);
```

参数说明:
- stream: 流句柄（uv_stream_t，可以是 TCP 或 Pipe）。
- backlog: 连接队列的最大长度。
- cb: 连接回调函数（uv_connection_cb）。

#### uv_accept

接受连接请求。

```c
int uv_accept(uv_stream_t* server, uv_stream_t* client);
```

参数说明:
- server: 服务器流句柄（uv_stream_t）。
- client: 客户端流句柄（uv_stream_t）。

#### uv_tcp_connect

发起 TCP 连接。

```c
int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle, const struct sockaddr* addr, uv_connect_cb cb);
```

参数说明:
- req: 连接请求句柄（uv_connect_t）。
- handle: TCP 句柄（uv_tcp_t）。
- addr: 目标地址（struct sockaddr）。
- cb: 连接完成回调函数（uv_connect_cb）。

### UDP 相关 API

#### uv_udp_init

初始化 UDP 句柄。

```c
int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle);
```

参数说明:
- loop: 事件循环对象（uv_loop_t）。
- handle: UDP 句柄（uv_udp_t）。

#### uv_udp_bind

将 UDP 句柄绑定到指定的地址和端口。

```c
int uv_udp_bind(uv_udp_t* handle, const struct sockaddr* addr, unsigned int flags);
```

参数说明:
- handle: UDP 句柄（uv_udp_t）。
- addr: 地址信息（struct sockaddr）。
- flags: 绑定标志（如 UV_UDP_REUSEADDR）。

#### uv_udp_recv_start

开始接收 UDP 数据。

```c
int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb);
```

参数说明:
- handle: UDP 句柄（uv_udp_t）。
- alloc_cb: 分配缓冲区的回调函数（uv_alloc_cb）。
- recv_cb: 接收数据的回调函数（uv_udp_recv_cb）。

#### uv_udp_recv_stop

停止接收 UDP 数据。

```c
int uv_udp_recv_stop(uv_udp_t* handle);
```

参数说明:
- handle: UDP 句柄（uv_udp_t）。

#### uv_udp_send

发送 UDP 数据。

```c
int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, const uv_buf_t* bufs, unsigned int nbufs, const struct sockaddr* addr, uv_udp_send_cb cb);
```

参数说明:
- req: 发送请求句柄（uv_udp_send_t）。
- handle: UDP 句柄（uv_udp_t）。
- bufs: 数据缓冲区数组（uv_buf_t）。
- nbufs: 缓冲区数量。
- addr: 目标地址（struct sockaddr）。
- cb: 发送完成回调函数（uv_udp_send_cb）。

### 通用 API

#### uv_read_start

开始读取数据。此 API 在 [文件系统](./文件系统.md#uv_read_start) 中也有介绍。

```c
int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb);
```

参数说明:
- stream: 流句柄（uv_stream_t）。
- alloc_cb: 分配缓冲区的回调函数（uv_alloc_cb）。
- read_cb: 读取数据的回调函数（uv_read_cb）。

#### uv_write

写入数据。此 API 在 [文件系统](./文件系统.md#uv_write) 中也有介绍。

```c
int uv_write(uv_write_t* req, uv_stream_t* handle, const uv_buf_t* bufs, unsigned int nbufs, uv_write_cb cb);
```

参数说明:
- req: 写请求句柄（uv_write_t）。
- handle: 流句柄（uv_stream_t）。
- bufs: 数据缓冲区数组（uv_buf_t）。
- nbufs: 缓冲区数量。
- cb: 写入完成回调函数（uv_write_cb）。

#### uv_close

关闭句柄。

```c
void uv_close(uv_handle_t* handle, uv_close_cb close_cb);
```

参数说明:
- handle: 需要关闭的句柄（uv_handle_t）。
- close_cb: 关闭完成回调函数（uv_close_cb）。

#### uv_ip4_addr

将字符串形式的 IPv4 地址和端口转换为 `struct sockaddr_in`。

```c
int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);
```

参数说明:
- ip: 字符串形式的 IPv4 地址（如 "127.0.0.1"）。
- port: 端口号（主机字节序）。
- addr: 输出的 struct sockaddr_in 结构。

### 回调函数类型

#### uv_connection_cb

连接回调函数。

```c
typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
```

参数说明:

- server: 服务器流句柄（uv_stream_t）。
- status: 连接状态（0 表示成功，负数表示错误）。

#### uv_connect_cb

连接完成回调函数。

```c
typedef void (*uv_connect_cb)(uv_connect_t* req, int status);
```

参数说明:
- req: 连接请求句柄（uv_connect_t）。
- status: 连接状态（0 表示成功，负数表示错误）。

#### uv_read_cb

读取数据回调函数。

```c
typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf);
```

参数说明:

- stream: 流句柄（uv_stream_t）。
- nread: 读取的字节数（>0 表示成功，0 表示 空回调，<0 表示错误）。
- buf: 数据缓冲区（uv_buf_t）。

`nread` 可能的值：
- nread > 0 ：读取到 nread 字节的数据，数据存储在 buf->base 中。
- nread == 0 ：libuv 可能给了一个空的读取回调，这种情况一般可以安全地忽略。
- nread < 0 ：发生错误或者流关闭：
    - UV_EOF：流结束（客户端或服务器关闭了连接）。
    - 其他负值：读取错误（如 UV_ECONNRESET 表示连接被重置）。

当 `nread` 等于 0 时，表示 libuv 成功调用了回调，但是 没有读取到任何数据。可能的原因：

- 流量控制：

    在某些情况下，libuv 可能会调用 `on_read` 但不返回数据（例如，缓冲区准备好但暂时没有数据）。

- 分配的缓冲区为空：
    
    alloc_buffer 提供的缓冲区可能未正确初始化，导致 `uv_read_start` 仍然触发回调，但数据长度为 0。

- 非阻塞 I/O 机制：
    
    libuv 是基于事件驱动的非阻塞 I/O，某些情况下 `on_read` 可能会被调用但没有数据到达，因此 nread == 0。

使用示例：

```c
// 设置read回调
uv_read_start((uv_stream_t *)client, alloc_buffer, echo_read);

// 回调处理函数，直接回略掉nread == 0的情况
void echo_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {
  if (nread > 0) {
    write_req_t *req = (write_req_t *)malloc(sizeof(write_req_t));
    printf("Received: %.*s\n", (int)nread, buf->base);
    req->buf = uv_buf_init(buf->base, nread);
    uv_write((uv_write_t *)req, client, &req->buf, 1, NULL);
    return;
  }
  if (nread < 0) {
    if (nread != UV_EOF) fprintf(stderr, "Read error %s\n", uv_err_name(nread));
    uv_close((uv_handle_t *)client, NULL);
  }

  if (buf->base) free(buf->base);
}
```

#### uv_write_cb

写入完成回调函数。

```c
typedef void (*uv_write_cb)(uv_write_t* req, int status);
```

参数说明:
- req: 写请求句柄（uv_write_t）。
- status: 写入状态（0 表示成功，负数表示错误）。

### POSIX socket API 与 libuv network API 对应关系总结


| **功能**            | **POSIX API**            | **libuv API**               | **区别**                                                                 |
|---------------------|--------------------------|-----------------------------|-------------------------------------------------------------------------|
| 创建套接字          | `socket()`               | `uv_tcp_init()` / `uv_udp_init()` | libuv 封装了套接字创建，直接操作句柄。                                   |
| 绑定地址            | `bind()`                 | `uv_tcp_bind()` / `uv_udp_bind()` | libuv 的绑定操作是异步的。                                               |
| 监听连接            | `listen()`               | `uv_listen()`               | libuv 的监听操作是异步的。                                               |
| 接受连接            | `accept()`               | `uv_accept()`               | libuv 的接受操作是异步的。                                               |
| 发起连接            | `connect()`              | `uv_tcp_connect()`          | libuv 的连接操作是异步的。                                               |
| 读取数据            | `read()` / `recv()`      | `uv_read_start()`           | libuv 的读取操作是异步的，数据通过回调传递。                             |
| 写入数据            | `write()` / `send()`     | `uv_write()`                | libuv 的写入操作是异步的。                                               |
| 关闭套接字          | `close()`                | `uv_close()`                | libuv 的关闭操作是异步的。                                               |
| 事件循环            | `select()` / `poll()`    | `uv_run()`                  | libuv 提供了统一的事件循环机制。                                         |
| DNS 解析            | `getaddrinfo()`          | `uv_getaddrinfo()`          | libuv 的 DNS 解析是异步的。                                              |
| 缓冲区管理          | `char[]` / `malloc()`    | `uv_buf_t` / `uv_buf_init()`| libuv 提供了统一的缓冲区管理接口。                                       |

### 示例代码：TCP 服务器

```{literalinclude} /src/libuv/tcp-echo-server/main.c
:language: c
```

### 示例代码：TCP 客户端

```{literalinclude} /src/libuv/tcp-echo-client/main.c
:language: c
```

## 参考资料

- [libuv documentation: uv_tcp_t — TCP handle](https://docs.libuv.org/en/v1.x/tcp.html)
- [libuv documentation: uv_udp_t — UDP handle](https://docs.libuv.org/en/v1.x/udp.html)