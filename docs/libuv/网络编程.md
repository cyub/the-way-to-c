# 网络编程

## 传统的网络编程方式

在 Linux 下进行 C 语言网络编程时，主要依赖于 POSIX 标准定义的系统调用和库函数。这些 API 提供了对网络通信的底层支持，包括创建套接字（Socket）、绑定地址、监听连接、接受连接、发送和接收数据等操作。

下图是一个典型的网络编程流程图：

```
       server               client
    +----------+         +----------+
    |  socket  |         |  socket  |
    +----------+         +----------+
        |                     |     
        |                     |     
        |                     |     
        v                     |     
    +----------+              |     
    |   bind   |              |     
    +----------+              |     
        |                     |     
        |                     |     
        |                     |     
        v                     |     
    +----------+              |     
    |  listen  |              |     
    +----------+              v     
        |               +----------+
        | <------------ |  connect |
        |               +----------+
        v                     |     
    +----------+              |     
    |  accept  |              |     
    +----------+              |     
        |                     |     
        |                     |     
        |                     |     
        v                     v     
    +----------+         +----------+
    | send/recv| <------ | send/recv|
    +----------+         +----------+
```

### 创建套接字

使用 `socket()` 系统调用来创建一个套接字。

```c
int socket(int domain, int type, int protocol);
```

参数说明：

- domain：指定协议族，如 AF_INET（IPv4）、AF_INET6（IPv6）或 AF_UNIX（本地通信）。
- type：指定套接字类型，如 SOCK_STREAM（TCP）、SOCK_DGRAM（UDP）或 SOCK_RAW（原始套接字）。
- protocol：指定协议，通常设置为 0，表示使用默认协议。

返回值：
- 成功时返回一个套接字描述符（非负整数）。
- 失败时返回 -1，并设置 errno。

### 绑定地址

使用 `bind()` 系统调用来将套接字绑定到一个本地地址和端口。

```c
int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```

参数说明：
- sockfd：套接字描述符。
- addr：指向 struct sockaddr 的指针，包含要绑定的地址和端口信息。
- addrlen：地址结构的长度。

返回值：
- 成功时返回 0。
- 失败时返回 -1，并设置 errno。

### 监听连接

使用 `listen()` 系统调用来将套接字转换为被动套接字，使其能够接收连接请求。

```c
int listen(int sockfd, int backlog);
```

参数说明：
- sockfd：套接字描述符。
- backlog：指定未完成连接队列的最大长度。

返回值：
- 成功时返回 0。
- 失败时返回 -1，并设置 errno。

### 接受连接

使用 `accept()` 系统调用来接受一个连接请求，返回一个新的套接字描述符用于与客户端通信。

```c
int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
```

参数说明：

- sockfd：监听套接字描述符。
- addr：指向 struct sockaddr 的指针，用于存储客户端地址信息。
- addrlen：地址结构的长度。


返回值：

- 成功时返回一个新的套接字描述符。
- 失败时返回 -1，并设置 errno。

### 发送和接收数据

使用 `send()` 和 `recv()` 系统调用来发送和接收数据。

```c
ssize_t send(int sockfd, const void* buf, size_t len, int flags);
ssize_t recv(int sockfd, void* buf, size_t len, int flags);
```

参数说明：
- sockfd：套接字描述符。
- buf：指向数据缓冲区的指针。
- len：缓冲区的长度。
- flags：控制选项，如 0（默认）、MSG_OOB（带外数据）等。

返回值：
- send()：成功时返回发送的字节数，失败时返回 -1。
- recv()：成功时返回接收的字节数，失败时返回 -1，到达文件末尾时返回 0。

### 关闭套接字

使用 `close()` 系统调用来关闭套接字。

```c
int close(int sockfd);
```

参数说明：
- sockfd：套接字描述符。

返回值：
- 成功时返回 0。
- 失败时返回 -1，并设置 errno。

### 示例代码：TCP 服务器

以下是一个简单的 TCP 服务器示例，展示了如何使用上述 API。

```{literalinclude} /src/libuv/tcp-server/main.c
:language: c
```

### 示例代码：TCP 客户端

以下是一个简单的 TCP 客户端示例，展示了如何使用上述 API。

```{literalinclude} /src/libuv/tcp-client/main.c
:language: c
```

### 示例代码：UDP 服务器

```{literalinclude} /src/libuv/udp-server/main.c
:language: c
```

### 示例代码：UDP 客户端

```{literalinclude} /src/libuv/udp-client/main.c
:language: c
```